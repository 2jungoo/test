#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/stat.h>

#define ACCOUNT_FILE "accounts.dat"
#define MAX_ACCOUNTS 1000

// 계좌 구조체
typedef struct {
    int account_num;
    char owner[50];
    char id[20];
    int balance;
    int is_active;
} Account;

// 함수 선언
void init_account_file();
void create_account();
void deposit();
void withdraw();
void check_balance();
void list_all_accounts();
int read_account(int account_num, Account *acc);
int write_account(int account_num, Account *acc);
off_t get_account_offset(int account_num);
int lock_record(int fd, int account_num, int lock_type);
int unlock_record(int fd, int account_num);

int main() {
    int choice;
    
    init_account_file();
    
    while (1) {
        printf("\n");
        printf("┌─────────────────────────────────┐\n");
        printf("│   은행 계좌 관리 시스템 (잠금)   │\n");
        printf("├─────────────────────────────────┤\n");
        printf("│ 1. 계좌 생성                    │\n");
        printf("│ 2. 입금                         │\n");
        printf("│ 3. 출금                         │\n");
        printf("│ 4. 잔액 조회                    │\n");
        printf("│ 5. 전체 계좌 조회               │\n");
        printf("│ 0. 종료                         │\n");
        printf("└─────────────────────────────────┘\n");
        printf("선택> ");
        
        scanf("%d", &choice);
        getchar();
        
        switch (choice) {
            case 1:
                create_account();
                break;
            case 2:
                deposit();
                break;
            case 3:
                withdraw();
                break;
            case 4:
                check_balance();
                break;
            case 5:
                list_all_accounts();
                break;
            case 0:
                printf("프로그램을 종료합니다.\n");
                return 0;
            default:
                printf("잘못된 선택입니다.\n");
        }
    }
    
    return 0;
}

// 계좌 파일 초기화
void init_account_file() {
    int fd = open(ACCOUNT_FILE, O_RDONLY);
    if (fd == -1) {
        fd = open(ACCOUNT_FILE, O_RDWR | O_CREAT, 0644);
        if (fd == -1) {
            perror("파일 생성 실패");
            return;
        }
        
        Account empty_acc = {0};
        for (int i = 0; i < MAX_ACCOUNTS; i++) {
            write(fd, &empty_acc, sizeof(Account));
        }
        
        printf("계좌 파일이 생성되었습니다.\n");
    }
    close(fd);
}

// 계좌번호에 따른 파일 오프셋 계산
off_t get_account_offset(int account_num) {
    return (account_num - 1) * sizeof(Account);
}

// 레코드 잠금 (fcntl 사용)
int lock_record(int fd, int account_num, int lock_type) {
    struct flock lock;
    
    lock.l_type = lock_type;      // F_RDLCK 또는 F_WRLCK
    lock.l_whence = SEEK_SET;     // 파일 시작부터
    lock.l_start = get_account_offset(account_num);  // 잠금 시작 위치
    lock.l_len = sizeof(Account); // 잠금 길이
    
    // 잠금 시도
    printf("레코드 잠금 시도 중... (계좌번호: %d)\n", account_num);
    
    if (fcntl(fd, F_SETLKW, &lock) == -1) {  // F_SETLKW: 블로킹 잠금
        perror("레코드 잠금 실패");
        return -1;
    }
    
    printf("레코드 잠금 성공!\n");
    return 0;
}

// 레코드 잠금 해제
int unlock_record(int fd, int account_num) {
    struct flock lock;
    
    lock.l_type = F_UNLCK;        // 잠금 해제
    lock.l_whence = SEEK_SET;
    lock.l_start = get_account_offset(account_num);
    lock.l_len = sizeof(Account);
    
    if (fcntl(fd, F_SETLK, &lock) == -1) {
        perror("레코드 잠금 해제 실패");
        return -1;
    }
    
    printf("레코드 잠금 해제!\n");
    return 0;
}

// 계좌 읽기 (읽기 잠금)
int read_account(int account_num, Account *acc) {
    int fd = open(ACCOUNT_FILE, O_RDONLY);
    if (fd == -1) {
        perror("파일 열기 실패");
        return -1;
    }
    
    // 읽기 잠금 설정
    if (lock_record(fd, account_num, F_RDLCK) == -1) {
        close(fd);
        return -1;
    }
    
    // 계좌번호 위치로 이동
    off_t offset = get_account_offset(account_num);
    lseek(fd, offset, SEEK_SET);
    
    // 계좌 정보 읽기
    int result = read(fd, acc, sizeof(Account));
    
    // 잠금 해제
    unlock_record(fd, account_num);
    close(fd);
    
    return result;
}

// 계좌 쓰기 (쓰기 잠금)
int write_account(int account_num, Account *acc) {
    int fd = open(ACCOUNT_FILE, O_RDWR);
    if (fd == -1) {
        perror("파일 열기 실패");
        return -1;
    }
    
    // 쓰기 잠금 설정
    if (lock_record(fd, account_num, F_WRLCK) == -1) {
        close(fd);
        return -1;
    }
    
    // 계좌번호 위치로 이동
    off_t offset = get_account_offset(account_num);
    lseek(fd, offset, SEEK_SET);
    
    // 계좌 정보 쓰기
    int result = write(fd, acc, sizeof(Account));
    
    // 잠금 해제
    unlock_record(fd, account_num);
    close(fd);
    
    return result;
}

// 계좌 생성
void create_account() {
    Account acc;
    int account_num;
    
    printf("\n[계좌 생성]\n");
    printf("계좌번호 (1-%d): ", MAX_ACCOUNTS);
    scanf("%d", &account_num);
    getchar();
    
    if (account_num < 1 || account_num > MAX_ACCOUNTS) {
        printf("계좌번호는 1부터 %d 사이여야 합니다.\n", MAX_ACCOUNTS);
        return;
    }
    
    // 기존 계좌 확인
    Account existing_acc;
    if (read_account(account_num, &existing_acc) > 0 && existing_acc.is_active) {
        printf("이미 사용 중인 계좌번호입니다.\n");
        return;
    }
    
    acc.account_num = account_num;
    acc.is_active = 1;
    
    printf("예금주: ");
    fgets(acc.owner, sizeof(acc.owner), stdin);
    acc.owner[strcspn(acc.owner, "\n")] = 0;
    
    printf("주민번호/ID: ");
    fgets(acc.id, sizeof(acc.id), stdin);
    acc.id[strcspn(acc.id, "\n")] = 0;
    
    printf("초기 입금액: ");
    scanf("%d", &acc.balance);
    
    if (acc.balance < 0) {
        printf("초기 입금액은 0 이상이어야 합니다.\n");
        return;
    }
    
    // 레코드 잠금 후 저장
    if (write_account(account_num, &acc) > 0) {
        printf("\n계좌가 생성되었습니다!\n");
        printf("계좌번호: %d\n", acc.account_num);
        printf("예금주: %s\n", acc.owner);
        printf("초기 잔액: %d원\n", acc.balance);
    } else {
        printf("계좌 생성에 실패했습니다.\n");
    }
}

// 입금
void deposit() {
    int account_num, amount;
    Account acc;
    
    printf("\n[입금]\n");
    printf("계좌번호: ");
    scanf("%d", &account_num);
    
    // 계좌 정보 읽기 (읽기 잠금)
    if (read_account(account_num, &acc) <= 0 || !acc.is_active) {
        printf("존재하지 않는 계좌입니다.\n");
        return;
    }
    
    printf("예금주: %s\n", acc.owner);
    printf("현재 잔액: %d원\n", acc.balance);
    printf("입금액: ");
    scanf("%d", &amount);
    
    if (amount <= 0) {
        printf("입금액은 0보다 커야 합니다.\n");
        return;
    }
    
    // 잔액 업데이트
    acc.balance += amount;
    
    // 레코드 잠금 후 저장 (쓰기 잠금)
    if (write_account(account_num, &acc) > 0) {
        printf("\n입금이 완료되었습니다.\n");
        printf("입금액: %d원\n", amount);
        printf("현재 잔액: %d원\n", acc.balance);
    } else {
        printf("입금 처리에 실패했습니다.\n");
    }
}

// 출금
void withdraw() {
    int account_num, amount;
    Account acc;
    
    printf("\n[출금]\n");
    printf("계좌번호: ");
    scanf("%d", &account_num);
    
    // 계좌 정보 읽기 (읽기 잠금)
    if (read_account(account_num, &acc) <= 0 || !acc.is_active) {
        printf("존재하지 않는 계좌입니다.\n");
        return;
    }
    
    printf("예금주: %s\n", acc.owner);
    printf("현재 잔액: %d원\n", acc.balance);
    printf("출금액: ");
    scanf("%d", &amount);
    
    if (amount <= 0) {
        printf("출금액은 0보다 커야 합니다.\n");
        return;
    }
    
    if (acc.balance < amount) {
        printf("잔액이 부족합니다. (부족액: %d원)\n", amount - acc.balance);
        return;
    }
    
    // 잔액 업데이트
    acc.balance -= amount;
    
    // 레코드 잠금 후 저장 (쓰기 잠금)
    if (write_account(account_num, &acc) > 0) {
        printf("\n출금이 완료되었습니다.\n");
        printf("출금액: %d원\n", amount);
        printf("현재 잔액: %d원\n", acc.balance);
    } else {
        printf("출금 처리에 실패했습니다.\n");
    }
}

// 잔액 조회
void check_balance() {
    int account_num;
    Account acc;
    
    printf("\n[잔액 조회]\n");
    printf("계좌번호: ");
    scanf("%d", &account_num);
    
    // 계좌 정보 읽기 (읽기 잠금)
    if (read_account(account_num, &acc) <= 0 || !acc.is_active) {
        printf("존재하지 않는 계좌입니다.\n");
        return;
    }
    
    printf("\n─────────────────────────\n");
    printf("계좌번호: %d\n", acc.account_num);
    printf("예금주: %s\n", acc.owner);
    printf("주민번호/ID: %s\n", acc.id);
    printf("잔액: %d원\n", acc.balance);
    printf("─────────────────────────\n");
}

// 전체 계좌 조회
void list_all_accounts() {
    int fd = open(ACCOUNT_FILE, O_RDONLY);
    if (fd == -1) {
        perror("파일 열기 실패");
        return;
    }
    
    printf("\n[전체 계좌 목록]\n");
    printf("──────────────────────────────────────────────────\n");
    printf("계좌번호\t예금주\t\t\t잔액\n");
    printf("──────────────────────────────────────────────────\n");
    
    Account acc;
    int count = 0;
    
    for (int i = 1; i <= MAX_ACCOUNTS; i++) {
        off_t offset = get_account_offset(i);
        lseek(fd, offset, SEEK_SET);
        
        if (read(fd, &acc, sizeof(Account)) > 0 && acc.is_active) {
            printf("%d\t\t%-20s\t%d원\n", 
                   acc.account_num, acc.owner, acc.balance);
            count++;
        }
    }
    
    printf("──────────────────────────────────────────────────\n");
    printf("총 %d개의 계좌\n", count);
    
    close(fd);
}
